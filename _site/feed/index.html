<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>Tu You</title>
    <link href="http://itouch2.github.io/feed/" rel="self" />
    <link href="http://webfrogs.github.com" />
    <lastBuildDate>2014-05-01T15:12:04+08:00</lastBuildDate>
    <webMaster>ccf.developer@gmail.com</webMaster>
    
    <item>
      <title>Unread 的 pull-for-menu</title>
      <link href="http://itouch2.github.io/2014/05/01/Unread%27s-pull-for-menu/"/>
      <pubDate>2014-05-01T00:00:00+08:00</pubDate>
      <author>Tu You</author>
      <guid>http://itouch2.github.io/2014/05/01/Unread's-pull-for-menu</guid>
      <content:encoded><![CDATA[<p><em>革命进化的解析</em></p>

<p>（本文译自：<a href="http://subjc.com/unread-overlay-menu/">Unread&#39;s pull-for-menu</a> ）</p>

<h2>背景</h2>

<p>在2013年中期，互联网的RSS世界有一个巨大的改变。Google 宣称他们的 RSS 订阅服务，<a href="http://www.google.com/reader/about/">Google Reader</a>，被关闭。对此，数百万的声音在惊慌中呼叫，然而突然间又销声匿迹了。</p>

<p>缩减的用户量是其宣称关闭Google Reader的原因，尽管来自 <a href="http://www.google.com/reader/about/">Google Reader</a> 的用户的强烈反应表明这项服务仍然有广大的用户群。虽然互联网有种乐观的意识认为对于在RSS方面对于很多公司有很多机会，因为以前这个服务的市场已经被像 Google 这样的巨头占领了，但是仍然存在对 RSS 的担忧。越来越多的 <a href="http://www.google.com/reader/about/">Google Reader</a> 的替代品出来。</p>

<p>尽管曾经有导致 RSS 消失的因素，RSS 至今仍活跃着，并且如今如 <a href="http://feedly.com/#discover">Feedly</a>, <a href="https://feedwrangler.net/welcome.html">Feedwrangler</a> 与 <a href="https://feedbin.com/">Feedbin</a> 正提供着 Google Reader 以前的服务。随之而来的是一大批现代的 iOS RSS 阅读器。在其中，有 <a href="http://jaredsinclair.com/unread/">Unread</a>，一个轻量干净并易于使用的提供上述服务的客户端 ，由 <a href="http://jaredsinclair.com/">Jared Sinclair</a>。在很短的时间里，它就在 app store 里有很多用户，多到很有可能你现在正通过 <a href="http://jaredsinclair.com/unread/">Unread</a> 阅读本文。</p>

<p>这篇文章是有关 <a href="http://jaredsinclair.com/unread/">Unread</a> 的 pull-for-menu 的交互，同时它也有关这个交互方面的历史，这些交互是怎么演变的。</p>

<h2>风景</h2>

<p>如果我们去探索 iOS 上的有关新闻与内容聚合的 app 的情况，我们可以发现像 <a href="http://flipboard.com/">Flipboard</a> 与 <a href="https://www.pulse.me/">Pulse</a> 这些的应用，这些应用不仅仅提供内容消费的服务，同时提供内容的探索。你可以想像自己使用它们，并在周日的早上一边喝着咖啡（或地球的另一端喝着下午茶）一边沉浸在阅读杂志的体验中。</p>

<p>在另一方面，我们有些应用如 <a href="http://reederapp.com/ios/">Reeder</a>，这种应用可以提供以一种最高效的方式来消费内容，这种应用你可以用来摆脱每天出行在路上的单调，使你避免 <a href="http://en.wikipedia.org/wiki/Fear_of_missing_out">FOMO</a>。此时你可以变想使用 <a href="http://jaredsinclair.com/unread/">Unread</a>。</p>

<p><a href="http://jaredsinclair.com/unread/">Unread</a> 延续了我们<a href="http://subjc.com/castro-playback-scrubber/">之前</a>讨论的限制的主题。它使用的方式很简单：你只要登录你的 RSS 订阅的账号，然后就可以开始享受阅读了。<a href="http://jaredsinclair.com/unread/">Unread</a> 提供了一个专门为单手用户设计的交互体验方式。</p>

<p>为了更好地认识 <a href="http://jaredsinclair.com/unread/">Unread</a> 的菜单交互方式的来源。让我们先从 Darwinistic 开始。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>自定义格式器</title>
      <link href="http://itouch2.github.io/2014/04/02/Custom-Formatters/"/>
      <pubDate>2014-04-02T00:00:00+08:00</pubDate>
      <author>Tu You</author>
      <guid>http://itouch2.github.io/2014/04/02/Custom-Formatters</guid>
      <content:encoded><![CDATA[<p>我们希望有一种快速的一次性的解决方案，可以把数据格式化为一种易读的格式。Foundation 框架中的就有 <code>NSFormatter</code> 可以很好地胜任这个工作。另外，在 Mac 上，Appkit 已经内建了 <code>NSFormatter</code> 的支持。</p>

<h2>内建格式器</h2>

<p>Foundation 框架中的 <code>NSFormatter</code> 是一个抽象类，它有两个已经实现的子类：<code>NSNumberFormatter</code> 与 <code>NSDateFormatter</code>。现在我们先跳过这些，来实现我们自己的子类。</p>

<p>如果你想了解更多的相关知识，我推荐阅读 <a href="http://nshipster.com/nsformatter/">NSHipster</a>。</p>

<h2>介绍</h2>

<p><code>NSFormatter</code> 除了抛出错误，其它什么事也不做。我还不知道有人想要用这个，当然如果它对你有用，就去用它吧。</p>

<p>因为我们不喜欢错误，我们在此实现一个 <code>NSFormatter</code> 的子类，它可以把 <code>UIColor</code> 实例转换成可读的名字。例如，以下代码可以返回字符串“Blue”:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">KPAColorFormatter *colorFormatter = [[KPAColorFormatter alloc] init];
[colorFormatter stringForObjectValue:[UIColor blueColor]] // Blue
</code></pre></div>
<p><code>NSFormatter</code> 的子类化有两个方法需要实现：<code>stringForObjectValue:</code> 与 <code>getObjectValue:ForString:errorDescription:</code>。我们先开始介绍第一个方法，因为这个方法更常用。第二个方法，就我所知，经常用于 OS X 上，并且通常不是很有用，我们将稍后介绍。</p>

<h2>初始化</h2>

<p>首先，我们需要做些初始化的工作。由于没有事先定义好的字典可以把颜色映射至名字，这些工作将由我们来完成。为了简化，这些工作将在初始化方法中完成：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">- (id)init;
{
    return [self initWithColors:@{
        [UIColor redColor]: @&quot;Red&quot;,
        [UIColor blueColor]: @&quot;Blue&quot;,
        [UIColor greenColor]: @&quot;Green&quot;
    }];
}
</code></pre></div>
<p>这里的 colors 是一个以 <code>UIColor</code> 实例为键，英语名为值的字典。大家可以自行地去实现 <code>initWithColors:</code> 方法。当然你也可以自行实现，或者直接前往 <a href="https://github.com/klaaspieter/KPAColorFormatter">Github repo</a> 获得答案。</p>

<h2>格式化对象值</h2>

<p>由于我们这里只可以格式化 <code>UIColor</code> 实例对象，于是在方法 <code>stringForObjectValue:</code> 中的第一件事就是判断传入的参数类型是否是 <code>UIColor</code> 类。</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">- (NSString *)stringForObjectValue:(id)value;
{
    if (![value isKindOfClass:[UIColor class]]) {
        return nil;
    }

    // To be continued...
}
</code></pre></div>
<p>在判断参数合法后，我们可以实现真正的逻辑了。我们的格式器中包含一个 <code>UIColor</code> 对象为键，颜色名为值的字典。因此，我们只需要以 <code>UIColor</code> 对象为键找到对应的值：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">- (NSString *)stringForObjectValue:(id)value;
{
    // Previously on KPAColorFormatter

    return [self.colors objectForKey:value];
}
</code></pre></div>
<p>以上代码是一个尽可能简单的实现。一个更高级（有用）的格式器应该是在我们的颜色字典中没有找到匹配的颜色时，返回一个最接近的颜色。大家可以自行实现，或是你不想花费太多功夫，可以前往 <a href="https://github.com/klaaspieter/KPAColorFormatter">Github repo</a>。</p>

<h2>反向格式化</h2>

<p>我们的格式器也应该支持反向格式化，即把字符串转成实例对象。这是通过 <code>getObjectValue:forString:errorDescription:</code> 方法实现。在 OS X 上，在使用 <code>NSCell</code> 时会经常用到这个方法。</p>

<p><code>NSCell</code> 有一个 <code>objectValue</code> 属性。默认情况下，<code>NSCell</code> 会用 <code>objectValue</code> 的描述，但是它也可以选择用一个格式器。在用 <code>NSTextFieldCell</code> 时，用户可以输入值，作为程序员，我们可能期望 <code>objedctValue</code> 可以根据根据输入的字符串转成一个 <code>UIColor</code> 实例。例如，用户如果输入“Blue”，我们需要返回一个 <code>[UIColor blueColor]</code> 实例的引用。</p>

<p>实现反向格式化分为两部分：一部分为当格式器可以成功地把字符串转成 <code>UIColor</code> 实例，另一部分当其不能成功转换。第一部分代码如下：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">- (BOOL)getObjectValue:(out __autoreleasing id *)obj 
             forString:(NSString *)string 
      errorDescription:(out NSString *__autoreleasing *)error;
{
    __block UIColor *matchingColor = nil;
    [self.colors enumerateKeysAndObjectsUsingBlock:^(UIColor *color, NSString *name, BOOL *stop) {
        if([name isEqualToString:string]) {
            matchingColor = color;
            *stop = YES;
        }
    }];

    if (matchingColor) {
        *obj = matchingColor;
        return YES;
    } // Snip
</code></pre></div>
<p>这里可以做一些优化，但是我们先不去做这些。以上方法会遍历我们颜色字典里的每一个对象 ，当一个颜色名字找到时，则会返回其对应关联的 <code>UIColor</code> 实例对象的引用，同时返回 YES 告知调用者我们已经成功地把字符串转成了一个 <code>UIColor</code> 实例对象。</p>

<p>现在处理第二部分：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">if (matchingColor) {
    // snap
} else if (error) {
    *error = [NSString stringWithFormat:@&quot;No known color for name: %@&quot;, string];
}

return NO;
</code></pre></div>
<p>这里，我们如果不能找到一个匹配的颜色，我们会检测调用者是否需要错误信息，如果需要，则把错误通过引用返回。这里检查错误很重要。如果你不这样做，程序就会 crash。同时，我们也会返回 NO，告知调用者这次转换失败。</p>

<h2>本地化</h2>

<p>到现在，我们已经建立了一个完全功能的 <code>NSFormatter</code> 的子类，当然这只是对于生活在美国的英语使用者而言有用。</p>

<p>但相比全世界 71.3 亿人，那才 3.19 亿。或者说，你还有 96% 的潜在用户。当然你可以说：这些潜在用户绝大部分都不是 iPhone 或 Mac 使用者，这么做有什么意思呢？这么想你就太扫兴了。</p>

<p><code>NSNumberFormatter</code> 与 <code>NSDateFormatter</code> 都有一个 locale 属性，它是 <code>NSLocale</code> 实例对象。我们现在来扩展格式器以支持本地化，让它可以根据 local 属性来返回对应翻译的名字。</p>

<h3>翻译</h3>

<p>首先，我们需要翻译颜色名字字符串。有关 genstring 与 *.lprojs 超出了本文的范围。有<a href="http://www.getlocalization.com/library/get-localization-mac/">很多文章</a>讨论这点。好了，不需要其它工作了，快要结束了。</p>

<h3>本地化的格式化</h3>

<p>接下来是本地化功能的实现。在获取翻译的字符串后，我们需要更新 <code>stringForObejectValue:</code> 方法。以前已经使用过 <code>NSLocalizedString</code> 的人可能已经早早的把每一个字符串都用 <code>NSLocalizedString</code> 替换了。但是我们不会这么做。</p>

<p>我们现在处理的是一个动态的 local，而 <code>NSLocalizedString</code> 只会查找当前默认的语言的翻译。在99%的情况下，这种默认的行为是你所想要的，但是我们会用格式化器的 locale 属性来动态查询语言。</p>

<p>以下是 <code>stringForObjectValue:</code> 的新的实现：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">- (NSString *)stringForObjectValue:(id)value;
{
    // Previously on... don&#39;t you hate these? I just watched that 20 seconds ago!

    NSString *languageCode = [self.locale objectForKey:NSLocaleLanguageCode];
    NSURL *bundleURL = [[NSBundle bundleForClass:self.class] URLForResource:languageCode 
                                                              withExtension:@&quot;lproj&quot;];
    NSBundle *languageBundle = [NSBundle bundleWithURL:bundleURL];
    return [languageBundle localizedStringForKey:name value:name table:nil];
}
</code></pre></div>
<p>上面的代码还有可以重构改进的地方，但因为把代码都放在同一个地方可以方便阅读，所以请大家多多包涵了。</p>

<p>首先，我们通过 locale 属性查找相应的语言，之后通过 NSBundle 找到对应的语言代码。最后，我们会让 bundle 对英语名称进行翻译。如果找不到对应的翻译，则会返回 name: 方法的参数（即英语名称）。如上即是 <code>NSLocalizedString</code> 的具体实现。</p>

<h3>本地化的反向格式化</h3>

<p>同样，我们也可以把颜色名称转成 <code>UIColor</code> 实例对象，当然，我认为这样做是不值得的。我们当前的实现适用于99%的情况。另外1%的情况是在 Mac 的 <code>NSCell</code> 上使用，而且你允许用户输入一个你试图解析的颜色的名字，这所需要做的要比简单的 子类化 NSFormatter 复杂很多。或许，你不应该允许你的用户通过文本输入颜色值。<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ApplicationKit/Classes/NSColorPanel_Class/">NSColorPanel</a> 在这里是一个更好的解决方案。</p>

<h2>属性化字符串</h2>

<p>到目前为止，我们的格式器都按我们预期的工作。接下来让我们做一个完全没用的功能，只是示范一下我们可以这么做，你懂的。</p>

<p>格式器同时支持属性化字符串。要不要支持它取决于你特定的应用与其用户界面。因此，你最好把这个功能做成可配置。</p>

<p>以下代码就是将文本颜色设置为当前正在格式化的颜色：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">- (NSAttributedString *)attributedStringForObjectValue:(id)value 
                                 withDefaultAttributes:(NSDictionary *)defaultAttributes;
{
    NSString *string = [self stringForObjectValue:value];

    if  (!string) {
        return nil;
    }

    NSMutableDictionary *attributes = [NSMutableDictionary dictionaryWithDictionary:defaultAttributes];
    attributes[NSForegroundColorAttributeName] = value;
    return [[NSAttributedString alloc] initWithString:string attributes:attributes];
}
</code></pre></div>
<p>首先，我们如之前一样处理字符串，然后检查格式化是否成功。然后我们把默认的属性值与前面设置的颜色属性结合后，最终返回属性化字符串。很容易，是吗？</p>

<h2>便捷</h2>

<p>因为初始化内建的格式器<a href="https://twitter.com/ID_AA_Carmack/status/28939697453">太慢了</a>，所以通常需要对外给你的格式器提供一个便利的类方法。这个格式器应该用默认值与当前的本地化环境。以下是格式器的实现：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">+ (NSString *)localizedStringFromColor:(UIColor *)color;
{
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        KPAColorFormatterReusableInstance = [[KPAColorFormatter alloc] init];
    });

    return [KPAColorFormatterReusableInstance stringForObjectValue:color];
}
</code></pre></div>
<p>除非你的格式器像 <code>NSNumberFormatter</code> 与 <code>NSDateFormatter</code> 一样做一些疯狂的事情 ，你可能不需要因为性能问题这么做。但是这样做也可以让使用格式器简单许多。</p>

<h2>总结</h2>

<p>我们的颜色格式器现在可以把一个 <code>UIColor</code> 实例格式成一个可读的名字或是反过来也行。当然还有放多有关 <code>NSFormatter</code> 的事情没有涉及。特别是在 Mac 上，因为它跟 <code>NSCell</code> 相关，你可以用更多高级的特性。例如当用户在编辑的时，你可以对字符串做一些检测。</p>

<p>我们的格式器还可以做更多自定义的事情。例如，在没查找到一个你需要的颜色名字时，我们可以返回给你最相近的颜色名字。有时，你可能需要我们的格式器有一个 Boolean 属性来控制该功能。或许我们的属性化字符串的格式化不是你想要的，并且应该支持更多自定义操作。</p>

<p>就此，我们完成了一个非常可靠的格式器。所有的代码（伴有 OS X 示例）都放在了 <a href="https://github.com/klaaspieter/KPAColorFormatter">Github</a> 上， 并且你也可以在 <a href="http://cocoapods.org/">CocoaPods</a> 上看到。如果你应用需要此功能，可以将 &quot;KPAColorFormatter&quot; 放在你的 Podfile 中，开始使用它吧。</p>

<hr>

<p><a href="http://objccn.io/issue-7/">语题 #7 下的更多文章</a></p>

<p>原文 <a href="http://www.objc.io/issue-7/nsformatter.html">Custom Formatters</a></p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
